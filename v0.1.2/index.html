<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · IndirectImports.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>IndirectImports.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Home</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Home</a></li></ul><a class="edit-page" href="https://github.com/tkf/IndirectImports.jl/blob/master/docs/src/index.md#L"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Home</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="IndirectImports.jl-1" href="#IndirectImports.jl-1">IndirectImports.jl</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndirectImports.IndirectImports" href="#IndirectImports.IndirectImports"><code>IndirectImports.IndirectImports</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p><strong>IndirectImports</strong></p><p><a href="https://tkf.github.io/IndirectImports.jl/stable"><img src="https://img.shields.io/badge/docs-stable-blue.svg" alt="Stable"/></a> <a href="https://tkf.github.io/IndirectImports.jl/dev"><img src="https://img.shields.io/badge/docs-dev-blue.svg" alt="Dev"/></a> <img src="https://img.shields.io/github/commits-since/tkf/IndirectImports.jl/v0.1.1.svg" alt="GitHub commits since tagged version"/> <a href="https://travis-ci.com/tkf/IndirectImports.jl"><img src="https://travis-ci.com/tkf/IndirectImports.jl.svg?branch=master" alt="Build Status"/></a> <a href="https://codecov.io/gh/tkf/IndirectImports.jl"><img src="https://codecov.io/gh/tkf/IndirectImports.jl/branch/master/graph/badge.svg" alt="Codecov"/></a> <a href="https://coveralls.io/github/tkf/IndirectImports.jl?branch=master"><img src="https://coveralls.io/repos/github/tkf/IndirectImports.jl/badge.svg?branch=master" alt="Coveralls"/></a></p><p>IndirectImports.jl lets Julia packages call and extend (a special type of) functions without importing the package defining them.  This is useful for managing optional dependencies.</p><ul><li><p>Compared to Requires.jl, IndirectImports.jl&#39;s approach is more static and there is no run-time <code>eval</code> hence more compiler friendly. However, unlike Requires.jl, both upstream and downstream packages need to rely on IndirectImports.jl API.</p></li><li><p>Compared to &quot;XBase.jl&quot; approach, IndirectImports.jl is more flexible in the sense that you don&#39;t need to create an extra package and keep it in sync with the &quot;implementation&quot; package(s).  However, unlike &quot;XBase.jl&quot; approach, IndirectImports.jl is usable only for functions, not for types.</p></li></ul><p><strong>Example</strong></p><pre><code class="language-julia"># MyPlot/src/MyPlot.jl
module MyPlot
    using IndirectImports

    @indirect function plot end  # declare an &quot;indirect function&quot;

    @indirect function plot(x)  # optional
        # generic implementation
    end
end

# MyDataFrames/src/MyDataFrames.jl
module MyDataFrames
    using IndirectImports

    @indirect import MyPlot  # this does not actually load MyPlot.jl

    # you can extend indirect functions
    @indirect function MyPlot.plot(df::MyDataFrame)
        # you can call indirect functions
        MyPlot.plot(df.columns)
    end
end</code></pre><p>You can install it with <code>]add IndirectImports</code>.  See more details in the <a href="https://tkf.github.io/IndirectImports.jl/dev/">documentation</a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/IndirectImports.jl/blob/535d00baaf48513ea91f6db493db17228610617f/src/IndirectImports.jl#LL1-L56">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndirectImports.@indirect-Tuple{Any}" href="#IndirectImports.@indirect-Tuple{Any}"><code>IndirectImports.@indirect</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@indirect function interface_function end</code></pre><p>Declare an <code>interface_function</code> in the upstream module (i.e., the module &quot;owning&quot; the function <code>interface_function</code>).  This function can be used and/or extended in downstream packages (via <code>@indirect import Module</code>) without loading the package defining <code>interface_function</code>. This from of <code>@indirect</code> works only at the top-level module.</p><pre><code class="language-julia">@indirect function interface_function(...) ... end</code></pre><p>Define a method of <code>interface_function</code> in the upstream module.  The function <code>interface_function</code> must be declared first by the above syntax.</p><p>This can also be used in downstream modules provided that <code>interface_function</code> is imported by <code>@indirect import Module: interface_function</code> (see below).</p><pre><code class="language-julia">@indirect import Module</code></pre><p>Import an upstream module <code>Module</code> indirectly.  This defines a constant named <code>Module</code> which acts like the module in a limited way. Namely, <code>Module.f</code> can be used to extend or call function <code>f</code>, provided that <code>f</code> in the actual module <code>Module</code> is declared to be an &quot;indirect function&quot; (see above).</p><pre><code class="language-julia">@indirect import Module: f1, f2, ..., fn</code></pre><p>Import &quot;indirect functions&quot; <code>f1</code>, <code>f2</code>, ..., <code>fn</code>.  This defines constants <code>f1</code>, <code>f2</code>, ..., and <code>fn</code> that are extendable (see above) and callable.</p><pre><code class="language-julia">@indirect function Module.interface_function(...) ... end</code></pre><p>Define a method of an indirectly imported function.  This form can be usable only in downstream modules where <code>Module</code> is imported via <code>@indirect import Module</code>.</p><p><strong>Examples</strong></p><p>Suppose you want extend functions in <code>Upstream</code> package in <code>Downstream</code> package without importing it.</p><p><strong>Step 1: Declare indirect functions in the Upstream package</strong></p><p>There must be a package that &quot;declares&quot; the ownership of an indirect function. Typically, such function is an interface extended by downstream packages.</p><p>To declare a function <code>fun</code> in a package <code>Upstream</code> wrap an empty definition of a function <code>function fun end</code> with <code>@indirect</code>:</p><pre><code class="language-julia">module Upstream
    using IndirectImports
    @indirect function fun end
end</code></pre><p>To define a method of an indirect function inside <code>Upstream</code>, wrap it in <code>@indirect</code>:</p><pre><code class="language-julia">module Upstream
    using IndirectImports
    @indirect function fun end

    @indirect fun() = 0  # defining a method
end</code></pre><p><strong>Step 2: Add the upstream package in the Downstream package</strong></p><p>Use Pkg.jl interface as usual to add <code>Upstream</code> package as a dependency of the <code>Downstream</code> package; i.e., type <code>]add Upstream⏎</code>:</p><pre><code class="language-julia-repl">(Downstream) pkg&gt; add Upstream</code></pre><p>This puts the entry <code>Upstream</code> in <code>[deps]</code> of <code>Project.toml</code>:</p><pre><code class="language-toml">[deps]
...
Upstream = &quot;xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx&quot;
...</code></pre><p>If it is not ideal to install <code>Upstream</code> by default, move it to <code>[extras]</code> section (you may need to create it manually):</p><pre><code class="language-toml">[extras]
Upstream = &quot;xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx&quot;</code></pre><p><strong>Step 3: Add method definitions in the Downstream package</strong></p><p>Once <code>Upstream</code> is registered in <code>Project.toml</code>, you can import <code>Upstream</code> and define its functions, provided that they are prefixed with <code>@indirect</code> macro:</p><pre><code class="language-julia">module Downstream
    using IndirectImports
    @indirect import Upstream
    @indirect Upstream.fun(x) = x + 1
    @indirect function Upstream.fun(x, y)
        return x + y
    end
end</code></pre><p><strong>Note</strong>: It looks like defining a method works without <code>@indirect</code> possibly due to a &quot;bug&quot; in Julia <a href="#footnote-1">[1]</a>.  While it is handy to define methods without <code>@indirect</code> for debugging, prototyping, etc., it is a good idea to wrap the method definition in <code>@indirect</code> to be forward compatible with future Julia versions.</p><div class="footnote" id="footnote-1"><a href="#footnote-1"><strong>[1]</strong></a><p>Extending a constructor is possible with only using <code>using</code>   <a href="https://github.com/JuliaLang/julia/issues/25744">https://github.com/JuliaLang/julia/issues/25744</a></p></div><p><strong>Limitation</strong></p><p>Function declarations can be documented as usual</p><pre><code class="language-julia">&quot;&quot;&quot;
Docstring for `fun`.
&quot;&quot;&quot;
@indirect function fun end</code></pre><p>but it does not work with the method definitions:</p><pre><code class="language-julia"># Commenting out the following errors:

# &quot;&quot;&quot;
# Docstring for `fun`.
# &quot;&quot;&quot;
@indirect function fun()
end</code></pre><p>To add a docstring to indirect functions in downstream packages, one workaround is to use &quot;off-site&quot; docstring:</p><pre><code class="language-julia">@indirect function fun() ... end

&quot;&quot;&quot;
Docstring for `fun`.
&quot;&quot;&quot;
fun</code></pre><p><strong>How it works</strong></p><p>See <a href="https://discourse.julialang.org/t/23526/38">https://discourse.julialang.org/t/23526/38</a> for a simple self-contained code to understanding the idea.  Note that the actual implementation is slightly different.</p></div></div><a class="source-link" target="_blank" href="https://github.com/tkf/IndirectImports.jl/blob/535d00baaf48513ea91f6db493db17228610617f/src/IndirectImports.jl#LL187-L360">source</a></section><footer><hr/><a class="next" href="internals/"><span class="direction">Next</span><span class="title">Internals</span></a></footer></article></body></html>
